/****************************************************************
*****************************************************************
    _/    _/  _/_/_/  _/       Numerical Simulation Laboratory
   _/_/  _/ _/       _/       Physics Department
  _/  _/_/    _/    _/       Universita' degli Studi di Milano
 _/    _/       _/ _/       Prof. D.E. Galli
_/    _/  _/_/_/  _/_/_/_/ email: Davide.Galli@unimi.it
*****************************************************************
*****************************************************************
Minor comments added by Aron Dallatomasina, 2026.


 * Random number generator based on the RANNYU algorithm (NYU, 1980s).
 *
 * RANNYU is a 48-bit Linear Congruential Generator (LCG) with prime addend:
 *   x_{n+1} = (a*x_{n}+c) mod m
 * where:
 *   - a is the multiplier,
 *   - c is the addend (a prime number),
 *   - m=2^48 is the modulus.
 * The parameters a, c and m are chosen to obtain the full period P=2^48≈10^14.
 * The random real number in the interval [0,1) is obtained as x_{n}/m.
 *
 * Implementation details:
 * The 48-bit internal state x_{n} is stored as four 12-bit integers (base-4096 representation), and all LCG operations are explicitly performed in base 4096.
 *   - This avoids integer overflows, since all intermediate arithmetic is performed using small integers.
 *   - It also ensures portability across architectures by avoiding reliance on large integer types and hardware-specific behavior.
 *
 * Parallel usage:
 * - Independent (statistically uncorrelated) random streams can be generated by choosing different prime addends c, allowing the construction of a parallel random number generator for parallel simulations.
 * - The conditions required for stream independence were derived by Percus and Kalos. Sets of valid prime addends are provided in external files:
 *   - Primes: 384 primes satisfying the independence criteria.
 *   - primes32001.in: 32001 primes (generated by G. Bertaina) following the same criteria, allowing for a large number of independent streams.
 * - In practice
 *   - Parallel random number generation is achieved by assigning a different prime addend c to each instance of the generator
 *   - Each instance advances its own state independently, and can be used concurrently (e.g. one stream per worker, thread, or process) within the same simulation.
 */


#pragma once

class Random {

	private:

		int m1, m2, m3, m4;								// Multiplier coefficients (a) written in base 4096
		int l1, l2, l3, l4;								// Internal 48-bit state (x_{n}) written in base 4096 (4 × 12-bit blocks)
		int n1, n2, n3, n4;								// Addend coefficients (c) written in base 4096. In this implementation n1=n2=0 and only the least significant 24 bits (n3 and n4) are used to define independent random streams

	protected:

	public:
	// Construction and initialization
		Random() = default;								// Default constructor
		~Random() = default;							// Default destructor
		void SetRandom(int* seed, int p1, int p2);		// Initialize the generator state and select the random stream
	// State I/O
		void SaveSeed();								// Save the current generator state to file
	// Random number generation
		double Rannyu();								// Uniform random number in [0,1)
		double Rannyu(double min, double max);			// Uniform random number in [min,max)
		double Gauss(double mean, double sigma);		// Gaussian random number N(mean, sigma)
		double Exponential(double lambda);				// Random number distributed according to exponential pdf with parameter lambda
		double CauchyLorentz(double mu, double Gamma);	// Random number distributed according to Cauchy-Lorentz pdf with center mu and width Gamma

};
